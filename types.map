TYPEMAP
CvArr*						T_CvPTROBJ
const CvArr*				T_CvPTROBJ
CvArr*						T_CvArrPtrPtr
const CvArr*				T_CvArrPtrPtr
IplImage*					T_CvPTROBJ
const IplImage*				T_CvPTROBJ
IplImage**	    			T_CvArrPtrPtr
const IplImage**			T_CvArrPtrPtr
const int*                  T_intPtr
CvSize                      T_CvSize

INPUT
T_CvPTROBJ
	if (sv_isobject($arg) && sv_derived_from($arg, \"@{
			$type =~ /\b(Cv|Ipl)(\w+)/; ['Cv::'.$2] }\")) {
		$var = INT2PTR(${type}, SvIV((SV*)SvRV($arg)));
	} else if (SvROK($arg) && SvIOK(SvRV($arg)) && SvIV(SvRV($arg)) == 0) {
		$var = (${type})0;
	} else
		Perl_croak(aTHX_ \"%s is not of type %s in %s\",
			\"$var\", \"@{(my $t = $type) =~ s/\bconst\s+//g; [$t]}\", \"$pname\")

T_CvArrPtrPtr
»   int length_$var = 0;
»   if (SvROK($arg) && SvTYPE(SvRV($arg)) == SVt_PVAV) {
»   »   AV* av = (AV*)SvRV($arg); length_$var = av_len(av) + 1;
»   »   if (length_$var > 0) { int i;
»   »   »   $var = ($type)alloca(sizeof(${var}[0]) * length_$var);
»   »   »   for (i = 0; i < length_$var; i++) {
»   »   »   »   SV* p = (SV*)*av_fetch(av, i, 0);
»   »   »   »   if (SvROK(p) && sv_derived_from(p, \"@{
»   »   »   »   »   »   $type =~ /\b(Cv|Ipl)(\w+)/; ['Cv::'.$2] }\"))
»   »   »   »   »   ${var}[i] = INT2PTR(@{
»   »   »   »   »   »   $type =~ /(const\s)?(\w+)[\s\*]+$/; [$2.'*']
»   »   »   »   »   }, SvIV((SV*)SvRV(p)));
»   »   »   »   else if (SvROK(p) && SvIOK(SvRV(p)) && SvIV(SvRV(p)) == 0)
»   »   »   »   »   ${var}[i] = (@{$type =~ /(const\s)?(\w+)[\s\*]+$/; [$2.'*']
»   »   »   »   »   })0;
»   »   »   »   else
»   »   »   »   »   Perl_croak(aTHX_ \"%s is not of type %s in %s\",
»   »   »   »   »   »   \"$var\", \"@{(my $t = $type) =~ s/\bconst\s+//g; [$t]}\", \"$pname\");
»   »   »   }
»   »   } else
»   »   »   $var = ($type)0;
»   } else if (SvROK($arg) && SvIOK(SvRV($arg)) && SvIV(SvRV($arg)) == 0) {
»   »   $var = ($type)0;
»   } else
»   »   Perl_croak(aTHX_ \"%s is not of type %s in %s\",
»   »   »   \"$var\", \"@{(my $t = $type) =~ s/\bconst\s+//g; [$t]}\", \"$pname\")

T_intPtr
»   int length_$var = 0;
»   STMT_START { int err = 0;
»   »   if (SvROK($arg) && SvTYPE(SvRV($arg)) == SVt_PVAV) {
»   »   »   AV* av = (AV*)SvRV($arg); length_$var = av_len(av) + 1;
»   »   »   if (length_$var > 0) { int i;
»   »   »   »   $var = ($type)alloca(sizeof(${var}[0]) * (length_$var + 1)); /* +1 for safety */
»   »   »   »   for (i = 0; i < length_$var; i++) {
»   »   »   »   »   SV* p = (SV*)*av_fetch(av, i, 0);
»   »   »   »   »   ((@{$type =~ /(const\s+)?(.*)/; [$2]})${var})[i] = SvIV(p);
»   »   »   »   }
»   »   »   } else
»   »   »   »   $var = ($type)0;
»   »   } else if (SvROK($arg) && SvIOK(SvRV($arg)) && SvIV(SvRV($arg)) == 0) {
»   »   »   $var = ($type)0;
»   »   } else
»   »   »   err++;
»   »   if (err)
»   »   »   Perl_croak(aTHX_ \"%s is not of type %s in %s\",
»   »   »   »   \"$var\", \"@{(my $t = $type) =~ s/\bconst\s+//g; [$t]}\", \"$pname\");
»   } STMT_END

T_CvSize
»   STMT_START {
»   »   SV* sv = $arg; AV* av;
»   »   if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVAV &&
»   »   »   av_len(av = (AV*)SvRV(sv)) >= 1) {
»   »   »   SV* sv_width  = (SV*)*av_fetch(av, 0, 0);
»   »   »   SV* sv_height = (SV*)*av_fetch(av, 1, 0);
»   »   »   $var.width  = SvIV(sv_width);
»   »   »   $var.height = SvIV(sv_height);
»   »   } else
»   »   »   Perl_croak(aTHX_ \"%s is not of type %s in %s\",
»   »   »   »   \"$var\", \"@{(my $t = $type) =~ s/\bconst\s+//g; [$t]}\", \"$pname\");
»   } STMT_END

OUTPUT
T_CvPTROBJ
    sv_setref_pv($arg, \"@{
		$type =~ /\b(Cv|Ipl)(\w+)/; ['Cv::'.$2] }\", (void*)$var);

T_intPtr
»   STMT_START {
»   »   AV* av; int i;
»   »   if (SvROK($arg) && SvTYPE(SvRV($arg)) == SVt_PVAV) {
»   »   »   av = (AV*)SvRV($arg);
»   »   »   av_clear(av);
»   »   } else {
»   »   »   av = newAV();
»   »   »   sv_setsv($arg, sv_2mortal(newRV_inc(sv_2mortal((SV*)av))));
»   »   }
»   »   for (i = 0; i < length_$var; i++) {
»   »   »   av_push(av, newSViv(${var}[i]));
»   »   }
»   } STMT_END;

T_CvSize
»   STMT_START {
»   »   AV* av = newAV();
»   »   av_push(av, newSViv($var.width));
»   »   av_push(av, newSViv($var.height));
»   »   sv_setsv($arg, sv_2mortal(newRV_inc(sv_2mortal((SV*)av))));
»   } STMT_END;

